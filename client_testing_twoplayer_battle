#include	"unp.h"
#include	"common.h"
#include  <string.h>
#include  <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>

char id[MAXLINE];

/* the following two functions use ANSI Escape Sequence */
/* refer to https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797 */


void clr_scr() {
	printf("\x1B[2J");
};

void set_scr() {		// set screen to 80 * 25 color mode
	printf("\x1B[=3h");
};

void xchg_data(FILE *fp, int sockfd)
{
    int       maxfdp1, stdineof, peer_exit, n;
    fd_set    rset;
    char      sendline[MAXLINE], recvline[MAXLINE];

	set_scr();
	clr_scr();

    Read(sockfd, recvline, MAXLINE);
	printf("recv(for sign): %s", recvline);

    Fgets(sendline, MAXLINE, fp);
    Writen(sockfd, sendline, strlen(sendline));

    Read(sockfd, recvline, MAXLINE);//read server id msg
	printf("recv(for id): %s", recvline); 

    Fgets(sendline, MAXLINE, fp);
    Writen(sockfd, sendline, strlen(sendline));

    Read(sockfd, recvline, MAXLINE);//read server 
	printf("recv (password message): %s", recvline);

    Fgets(sendline, MAXLINE, fp);//read cli password
    Writen(sockfd, sendline, strlen(sendline));
    printf("ready to enter thread guestroom\n");

    Read(sockfd, recvline, MAXLINE);//read server 
	printf("recv (cli choice): %s", recvline);
    Fgets(sendline, MAXLINE, fp);//read choice
    Writen(sockfd, sendline, strlen(sendline));

	printf("please wait for the game to start!!!\n");

	//Read(sockfd, recvline, MAXLINE);//read server (start message)
	//printf("recv (cli choice): %s", recvline); 


	memset(recvline,'\0',strlen(recvline));
	printf("waiting for the question\n");
	Read(sockfd, recvline, MAXLINE);//read server question 
	printf("finish for the question\n");
	//printf("recv (all question): %s", recvline);
	stdineof = 0;
	peer_exit = 0;
	/*for ( ; ; ) {	
		printf("waiting for the question\n");
		FD_ZERO(&rset);
		FD_SET(sockfd, &rset);
        maxfdp1 = sockfd+1;
        Select(maxfdp1, &rset, NULL, NULL, NULL);
		printf("start detect for the question\n");
		if (FD_ISSET(sockfd, &rset)) {  
			n = read(sockfd, recvline, MAXLINE);
			if (n <= 0) {
				printf("not reading anything\n");
 		   		if (stdineof == 1)
                    return;        
		   		else {
					printf("(End of input from the peer!)");
					peer_exit = 1;
					return;
				};
            }
			else if (n > 0) {
				recvline[n] = '\0';
				printf("recv (all question): %s", recvline);
				break;
			};
        }
    }*/

	int type;
    int num;
    int count = 0;
    int countq = 0;
	int current = 0;
    sscanf(recvline,"%d,%d",&type,&num);
    char qq[30][MAXLINE];
    for (int i=0;i<strlen(recvline);i++){
		//printf("checking question %d\n",i);
        if (recvline[i] == '<'){
            count = 0;
            for ( ; ; ){
                i++;
                if (recvline[i] == '>') break;
                qq[countq][count] = recvline[i];
                count++;
            }
            countq++;
        }
		printf("finish checking\n");
    }
    
    
	clock_t a1,a2;
	struct climsg *msg = (struct climsg *)malloc(sizeof(struct climsg));
	num = 3;
	printf("start giving question? num: %d\n",num);
	for (int i=0;i<num;i++){
		int readserv = 0;
		printf("Here is the question~ %s\n%s\n%s\n%s\n%s\n",qq[i*5],qq[i*5+1],qq[i*5+2],qq[i*5+3],qq[i*5+4]);//print question
		a1 = clock();
		a2 = a1;
		int persec = 100;
		for ( ; ; ) {
			a2 = clock();
			printf("time %f (a1:%d  a2:%d),(readserv: %d)\n",(double)(a2 - a1)/persec,a1,a2,readserv);
			struct timeval timeout;
			timeout.tv_sec = 1;  // 5 seconds timeout
			timeout.tv_usec = 0;
			if (a2 > a1 + 10*persec ){
				
				a1 = 1000*persec;
				memset(msg, 0, sizeof(struct climsg));
				msg->type = ANSWER;
				msg->ans = -1;
				msg->anstime = 10000;
				serialize_climsg(msg,sendline, 11);
				Writen(sockfd, sendline, strlen(sendline));
				printf("time up next round!!! send : %s\n",sendline);
			}	
			FD_ZERO(&rset);
			maxfdp1 = 0;
			if (stdineof == 0) {
				FD_SET(fileno(fp), &rset);
				maxfdp1 = fileno(fp);
			};	
			if (peer_exit == 0) {
				FD_SET(sockfd, &rset);
				if (sockfd > maxfdp1)
					maxfdp1 = sockfd;
			};	
			maxfdp1++;
			Select(maxfdp1, &rset, NULL, NULL, &timeout);
			if (FD_ISSET(sockfd, &rset)) {  /* socket is readable */
				n = read(sockfd, recvline, MAXLINE);
				readserv++;
				if (n == 0) {
					if (stdineof == 1)
						return;         /* normal termination */
					else {
						printf("(End of input from the peer!)");
						peer_exit = 1;
						return;
					};
				}
				else if (n > 0) {
					recvline[n] = '\0';
					char pid[1000];
					int sc,right;
					sscanf(recvline,"2 %s %d %d\0",id,&sc,&right);
					printf("recv from server ~ id: %s score change: %d  correct or no? : %d\n",id,sc,right);
					if (readserv >= 2) break;
				};
			}
			if (FD_ISSET(fileno(fp), &rset)) {  /* input is readable */
				if (Fgets(sendline, MAXLINE, fp) == NULL) {
					if (peer_exit)
						return;
					else {
						printf("(leaving...)\n");
						stdineof = 1;
						Shutdown(sockfd, SHUT_WR);      /* send FIN */
					};
				}
				else {
					a2 = clock();
					memset(msg, 0, sizeof(struct climsg));
					int ans;
					sscanf(sendline,"%d",&ans);
					msg->type = ANSWER;
					msg->ans = ans;
					msg->anstime = (time_t)(a2 - a1);
					serialize_climsg(msg,sendline, 11);
					Writen(sockfd, sendline, strlen(sendline));
					printf("you sent the answer,wait for your opponent,time is %d\n",(a2 - a1)/persec);
				};
			}
    	}
		printf("break out from loop\n");
	}
	Read(sockfd, recvline, MAXLINE);//read server question 
	printf("final result: %s\n",recvline);
    
};

int
main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_in	servaddr;

	if (argc != 3)
		err_quit("usage: tcpcli <IPaddress> <ID>");

	sockfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT+3);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);
	strcpy(id, argv[2]);

	Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

	xchg_data(stdin, sockfd);		/* do it all */

	exit(0);
}
